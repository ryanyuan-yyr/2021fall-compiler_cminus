/**
 * @file complex_num_cal.cminus
 * @author Yurun Yuan PB19111692
 * @brief A complex number calculator. Used as demos for cminusf compiler. 
 * @version 0.1
 * @date 2021-12-25
 * 
 */

struct complex_num
{
    float real;
    float imaginary;

    /**
     * @return Returns |z|^2 for a complex number z.
     */
    float modulus_sqare()
    {
        return (*this).real * (*this).real + (*this).imaginary * (*this).imaginary;
    }

    /**
     * @return For a complex number a + b*i, returns a - b*i. 
     */
    struct complex_num conjugate()
    {
        struct complex_num res;
        res.real = (*this).real;
        res.imaginary = 0.0 - (*this).imaginary;
        return res;
    }
    struct complex_num operator+(struct complex_num rhs)
    {
        struct complex_num res;
        res.real = (*this).real + rhs.real;
        res.imaginary = (*this).imaginary + rhs.imaginary;
        return res;
    }
    struct complex_num operator-(struct complex_num rhs)
    {
        struct complex_num res;
        res.real = (*this).real - rhs.real;
        res.imaginary = (*this).imaginary - rhs.imaginary;
        return res;
    }
    struct complex_num operator*(struct complex_num rhs)
    {
        struct complex_num res;
        res.real = (*this).real * rhs.real - (*this).imaginary * rhs.imaginary;
        res.imaginary = (*this).real * rhs.imaginary + (*this).imaginary * rhs.real;
        return res;
    }
    struct complex_num operator/(struct complex_num rhs)
    {
        struct complex_num res;
        float denominator = rhs.modulus_sqare();
        res = (*this) * rhs.conjugate();
        res.real = res.real / denominator;
        res.imaginary = res.imaginary / denominator;
        return res;
    }
};

struct complex_num plus(struct complex_num *lhs, struct complex_num *rhs)
{
    return *lhs + *rhs;
}

struct complex_num subtract(struct complex_num *lhs, struct complex_num *rhs)
{
    return *lhs - *rhs;
}

struct complex_num multiply(struct complex_num *lhs, struct complex_num *rhs)
{
    return *lhs * *rhs;
}

struct complex_num divide(struct complex_num *lhs, struct complex_num *rhs)
{
    return *lhs / *rhs;
}

/**
 * @brief An array of functions. To store functions that
 *        perform arithmetic operations for complex numbers. 
 */
struct complex_num (*function_table[4])(struct complex_num *, struct complex_num *);

struct complex_num (*get_function(int op))(struct complex_num *, struct complex_num *)
{
    if (op == 43) /* plus */
        op = 0;
    else if (op == 45) /* minus */
        op = 1;
    else if (op == 42) /* multiply */
        op = 2;
    else
        op = 3;

    return function_table[op];
}

int is_add_op(int op)
{
    if (op == 43)
        return 1;
    if (op == 45)
        return 1;
    return 0;
}

int is_mul_op(int op)
{
    if (op == 42)
        return 1;
    if (op == 47)
        return 1;
    return 0;
}

int char_to_int(int c)
{
    if (c >= 48)
        if (c <= 57)
            return c - 48;
    return 0 - 1;
}

struct complex_num read_complex_num(int **iter_ptr)
{
    struct complex_num res;
    float num;
    num = 0;
    while (char_to_int(**iter_ptr) != 0 - 1)
    {
        num = num * 10 + char_to_int(**iter_ptr);
        *iter_ptr = *iter_ptr + 1;
    }
    if (**iter_ptr == 105)
    {
        res.real = 0;
        res.imaginary = num;
        *iter_ptr = *iter_ptr + 1;
    }
    else
    {
        res.real = num;
        res.imaginary = 0;
    }
    return res;
}

void output_complex_num(struct complex_num num)
{
    print_float(num.real);
    print_char(32);
    print_float(num.imaginary);
    print_char(105);
    print_char(10);
}

template <typename T>
struct stack
{
    typename T *mem;
    int sp;
    void init(int size)
    {
        (*this).mem = reinterpret_cast<typename T *>(allocate(size * 8));
        (*this).sp = 0;
    }
    void drop()
    {
        deallocate(reinterpret_cast<int *>((*this).mem));
    }
    void push(typename T elem)
    {
        (*this).mem[(*this).sp] = elem;
        (*this).sp = (*this).sp + 1;
    }
    typename T top()
    {
        return (*this).mem[(*this).sp - 1];
    }
    typename T pop()
    {
        (*this).sp = (*this).sp - 1;
        return (*this).mem[(*this).sp];
    }
};

int main()
{
    /* Initialize */
    function_table[0] = plus;
    function_table[1] = subtract;
    function_table[2] = multiply;
    function_table[3] = divide;

    int terminator = 10;
    int l_paren = 40;
    int r_paren = 41;
    int *cur_pos;
    int *input;
    input = reinterpret_cast<int *>(allocate(512 * 4));
    cur_pos = input;

    int cur_char;
    cur_char = input_char();
    while (cur_char != terminator)
    {
        *cur_pos = cur_char;
        cur_pos = cur_pos + 1;
        cur_char = input_char();
    }
    *cur_pos = terminator;

    cur_pos = input;
    struct stack<struct complex_num> operands;
    operands.init(512);
    struct stack<int> operators;
    operators.init(512);
    while (*cur_pos != terminator)
    {
        if (char_to_int(*cur_pos) != 0 - 1)
        {
            operands.push(read_complex_num(&cur_pos));
        }
        else if (*cur_pos == 105)
        {
            struct complex_num unit;
            unit.real = 0;
            unit.imaginary = 1;
            operands.push(unit);
            cur_pos = cur_pos + 1;
        }
        else if (*cur_pos == l_paren)
        {
            operators.push(*cur_pos);
            cur_pos = cur_pos + 1;
        }
        else if (*cur_pos == r_paren)
        {
            while (operators.sp * (operators.top() - l_paren) != 0)
            {
                struct complex_num rhs = operands.pop();
                struct complex_num lhs = operands.pop();
                operands.push(get_function(operators.pop())(&lhs, &rhs));
            }
            operators.pop();
            cur_pos = cur_pos + 1;
        }
        else if (is_add_op(*cur_pos) == 1)
        {
            while (operators.sp * (operators.top() - l_paren) != 0)
            {
                struct complex_num rhs = operands.pop();
                struct complex_num lhs = operands.pop();
                operands.push(get_function(operators.pop())(&lhs, &rhs));
            }
            operators.push(*cur_pos);
            cur_pos = cur_pos + 1;
        }
        else if (is_mul_op(*cur_pos) == 1)
        {
            while (operators.sp * is_mul_op(operators.top()) != 0)
            {
                struct complex_num rhs = operands.pop();
                struct complex_num lhs = operands.pop();
                operands.push(get_function(operators.pop())(&lhs, &rhs));
            }
            operators.push(*cur_pos);
            cur_pos = cur_pos + 1;
        }
        else
            return 0 - 1;
    }
    while (operators.sp != 0)
    {
        struct complex_num rhs = operands.pop();
        struct complex_num lhs = operands.pop();
        operands.push(get_function(operators.pop())(&lhs, &rhs));
    }
    if (operands.sp != 1)
        return 0 - 1;
    if (operators.sp != 0)
        return 0 - 1;
    output_complex_num(operands.top());

    deallocate(reinterpret_cast<int *>(input));
    operands.drop();
    operators.drop();
    return 0;
}
